@page "/user/{userId:int}/settings/earth"
@using LBPUnion.ProjectLighthouse.Extensions
@using LBPUnion.ProjectLighthouse.Servers.Website.Types
@using LBPUnion.ProjectLighthouse.Types.Misc
@model LBPUnion.ProjectLighthouse.Servers.Website.Pages.EarthEditorPage

@{
    Layout = "Layouts/BaseLayout";
    Model.Title = "Earth Editor";
    Model.ShowTitleInPage = true;

    bool isMobile = Request.IsMobile();
    string language = Model.GetLanguage();
    string timeZone = Model.GetTimeZone();
}

<script src="https://unpkg.com/konva@8/konva.min.js"></script>
<div id="container"></div>
<script>
  let container = document.getElementById("container");
  let width = container.getBoundingClientRect().width;
  let height = window.innerHeight;
  let stage = new Konva.Stage({
    container: 'container',
    width: width,
    height: height,
    draggable: false,
  });

  // add canvas element
  let mapLayer = new Konva.Layer();
  stage.add(mapLayer);
  
  let mapImage = new Image();
  mapImage.onload = function () {
    mapImage.width = width;
    stage.height(mapImage.height);
    // mapImage.height = height;
    console.log(mapImage);
    let img = new Konva.Image({
          image: mapImage, 
    });
    mapLayer.add(img);
  }
  mapImage.src = "/assets/earthMap.png";
  
  
  let objectLayer = new Konva.Layer();

  // create shape
  @{
    Location profileLocation = Model.UserEarth.GetProfileLocation();
    float scaledX = (profileLocation.X / 65535f);
    float scaledY = (profileLocation.Y / 32767f);
  }
  console.log("@scaledX");
  console.log("@scaledY");
  let box = new Konva.Rect({
    x: (@scaledX * mapImage.width) - 25,
    y: (@scaledY * mapImage.height) - 27,
    width: 50,
    height: 55,
    fill: '#ffffff',
    stroke: 'black',
    strokeWidth: 1,
    draggable: true,
  });


  @{
    int i = 0;
  }
  @foreach (KeyValuePair<Location, LocationType> l in Model.UserEarth.Locations.Where(l => l.Value == LocationType.Level))
  {
    scaledX = (l.Key.X / 65535f);
    scaledY = (l.Key.Y / 32767f);
    <text>
    objectLayer.add(new Konva.Circle(
    {
      x: (@scaledX * mapImage.width),
      y: (@scaledY * mapImage.height),
      radius: 20,
      fill: '#cccccc',
      // stroke: 'white',
      // strokeWidth: 2,
      draggable: true,
    }));
    </text>
    i++;
  }
 
  objectLayer.add(box);
  // objectLayer.add(circle)
  
  stage.add(objectLayer);

  // add cursor styling
  objectLayer.on('mouseover', function () {
    document.body.style.cursor = 'pointer';
  });
  objectLayer.on('mouseout', function () {
    document.body.style.cursor = 'default';
  });

  let scaleBy = 1.1;
  // stage.on("dragmove", (e) => {
  //   let pos = stage.position();
  //   let needsMove = false;
  //   if (pos.x > 0){
  //     needsMove = true;
  //     pos.x = 0;
  //   }
  //   if (pos.y > 0){
  //     needsMove = true;
  //     pos.y = 0;
  //   }
  //   console.log(pos.y * stage.scaleX() + " > " + stage.height());
  //   if (pos.y < -stage.height){
  //     pos.y = -stage.height;
  //     needsMove = true;
  //   }
  //   if (pos.x < -stage.width){
  //     pos.x = -stage.width;
  //     needsMove = true;
  //   }
  //   if (needsMove){
  //     stage.position({x: pos.x, y: pos.y});
  //   }    
  // });
  // stage.on('wheel', (e) => {
  //     // stop default scrolling
  //     e.evt.preventDefault();
  //
  //     let oldScale = stage.scaleX();
  //     let pointer = stage.getPointerPosition();
  //
  //     let mousePointTo = {
  //           x: (pointer.x - stage.x()) / oldScale,
  //           y: (pointer.y - stage.y()) / oldScale,
  //     };
  //
  //     // how to scale? Zoom in? Or zoom out?
  //     let direction = e.evt.deltaY > 0 ? -1 : 1;
  //
  //     // when we zoom on trackpad, e.evt.ctrlKey is true
  //     // in that case lets revert direction
  //     if (e.evt.ctrlKey) {
  //         direction = -direction;
  //     }
  //
  //     let newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;
  //    
  //     if (newScale < 1 || newScale > 3) {
  //       return;
  //     }
  //
  //     stage.scale({ x: newScale, y: newScale });
  //
  //     let newPos = {
  //         x: pointer.x - mousePointTo.x * newScale,
  //         y: pointer.y - mousePointTo.y * newScale,
  //     };
  //     if (newPos.x < 0)
  //       newPos.x = 0;
  //     if (newPos.y < 0)
  //       newPos.y = 0;
  //     stage.position(newPos);
  // });
  
  
</script>

@* <script> *@
@* class MapRegion { *@
@*   constructor (img) { *@
@*     this.img = img *@
@*     this.w = img.width *@
@*     this.h = img.height *@
@*   } *@
@*    *@
@*   draw (ctx) { *@
@*     console.log(this.w); *@
@*     console.log(this.h); *@
@*     ctx.drawImage(this.img, 0, 0, ctx.canvas.width, ctx.canvas.height); *@
@*   } *@
@* } *@
@* class Camera { *@
@*   constructor (x, y) { *@
@*     // x and y are top-left coordinates of the camera rectangle relative to the map. *@
@*     // This rectangle is exctaly cvs.width px wide and cvs.height px tall. *@
@*     this.x = x || 0 *@
@*     this.y = y || 0 *@
@*     this.zoom = 1 *@
@*   } *@
@*    *@
@*   // focus (cvs, map, player) { *@
@*   //   // Account for half of player w/h to make their rectangle centered *@
@*   //   this.x = this.clamp(player.x - cvs.width / 2 + player.w / 2, 0, map.w - cvs.width) *@
@*   //   this.y = this.clamp(player.y - cvs.height / 2 + player.h / 2, 0, map.h - cvs.height) *@
@*   // } *@
@*    *@
@*   clamp (coord, min, max) { *@
@*     if (coord < min) { *@
@*       return min *@
@*     } else if (coord > max) { *@
@*       return max *@
@*     } else { *@
@*       return coord *@
@*     } *@
@*   } *@
@* } *@
@* const canvas = document.getElementById("canvas"); *@
@* const ctx = canvas.getContext("2d"); *@
@* const mapImage = new Image(); *@
@* mapImage.src = "/assets/earthMap.png"; *@
@* mapImage.addEventListener('load', setup); *@
@* *@
@* let map; *@
@* let camera; *@
@* console.log(canvas); *@
@* *@
@* function getCanvasSize(){ *@
@*   return canvas.getBoundingClientRect(); *@
@* } *@
@* *@
@* function setup(){ *@
@*   canvas.width = getCanvasSize().width; *@
@*   canvas.height = getCanvasSize().width / 2; *@
@*   mapImage.width = canvas.width+200; *@
@*   mapImage.height = canvas.height; *@
@*   map = new MapRegion(mapImage) *@
@*   console.log(mapImage); *@
@*   console.log(map); *@
@*   camera = new Camera(0, 0); *@
@*   requestAnimationFrame(draw); *@
@* } *@
@* *@
@* function draw(){ *@
@*   // Reset *@
@*       ctx.setTransform(1, 0, 0, 1, 0, 0) *@
@*       ctx.clearRect(0, 0, canvas.width, canvas.height) *@
@*        *@
@*       // Reposition player *@
@*       // player.update(map) *@
@*    *@
@*       // Focus camera *@
@*       // camera.focus(cvs, map, player) *@
@*       // Flip the sign b/c positive shifts the canvas to the right, negative - to the left *@
@*       ctx.scale(camera.zoom, camera.zoom); *@
@*       ctx.translate(-camera.x * camera.zoom, -camera.y * camera.zoom) *@
@*        *@
@*    *@
@*       // Draw *@
@*       map.draw(ctx) *@
@*       // player.draw(ctx) *@
@* } *@
@* </script> *@